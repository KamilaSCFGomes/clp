               _
   _       _ _(_)_
  (_)     | (_) (_)
   _ _   _| |_  __ _
  | | | | | | |/ _` |
  | | |_| | | | (_| |
 _/ |\__'_|_|_|\__'_|
|__/

Cap√≠tulo 1: üçí Julia

    Julia √© uma linguagem de alto nivel, prop√≥sito geral, e programa√ß√£o din√¢mica, projetada para ser r√°pida e produtiva. 
    Possui lican√ßa MIT - livre para uso, modifica√ß√£o e distribui√ß√£o
    
    Come√ßou a ser desenvolvida em 2009, quando 4 estudantes se juntaram para criar uma linguagem de gra√ßa que era tanto de alto-n√≠vel quanto r√°pida.
    O nome "Julia" n√£o tem nenhum motivo, s√≥ acharam que era um nome bonito.
    A vers√£o est√°vel foi lan√ßada em 2018.

    "Looks like python, feels like lisp, runs like C"
    Caracter√≠sticas:
        - Expressiva (muitas opera√ß√µes) e pouco verbosa.
        - Capaz de lidar com metaprograma√ß√£o (programa manipula a si mesmo).
        - Muito r√°pida.
    
    Implementa√ß√£o:
        - Compilada JIT (Just-In-Time) - tradu√ß√£o de c√≥digo durante execu√ß√£o
        - C√≥digo √© interpretado na primeira execu√ß√£o e depois otimizado para desempenho.

    Aplica√ß√µes:
        - Computa√ß√£o cient√≠fica, Machine Learning, IA, Desenvolvimento web, Processamento de dados


Cap√≠tulo 2: üçÉ Paradigmas e suas limita√ß√µes
    
    Multiparadigma:
        - Suporta programa√ß√£o funcional, orientada a objetos (de forma limitada) e procedural.
        - Paradigma principal: m√∫ltiplo despacho (seleciona o m√©todo mais adequado com base nos tipos de todos os argumentos).

    Limita√ß√µes da Orienta√ß√£o a Objetos:
        - N√£o possui modificadores de acesso (public, private, protected como em Java).
        - Conven√ß√£o: _ no in√≠cio da vari√°vel indica que algo n√£o deve ser acessado diretamente.
        - N√£o possui interfaces, mas podem ser simuladas com estruturas abstratas.
        - N√£o suporta heran√ßa de classes, mas permite composi√ß√£o e uso de tipos abstratos com o operador <: (define subtipos).
            * Entidade.jl e Produto.jl *
        - N√£o possui classes e objetos tradicionais como em Java, mas pode-se usar struct para modelar dados:
        - struct: Tipo imut√°vel (n√£o pode modificar atributos).
        - mutable struct: Tipo mut√°vel (permite modificar atributos). (Registro)
            * Package data *

    Construtor:
        - Criado dentro do pr√≥prio struct.
        - Pode ser padr√£o (autom√°tico) ou personalizado.
            * Package entidades *

    Destrutor:
        - Julia n√£o tem destrutores expl√≠citos.
        - A desaloca√ß√£o de mem√≥ria ocorre automaticamente pelo coletor de lixo.

Cap√≠tulo 3: üå∫ Adicionais

    Vincula√ß√£o Din√¢mica:
        - M√∫ltiplo despache substitui a necessidade de vincula√ß√£o din√¢mica tradicional.
        - M√©todos s√£o escolhidos dinamicamente com base nos tipos dos argumentos.
            * Package entidades *
        
    Aloca√ß√£o e Desaloca√ß√£o:
        - Feitas automaticamente

    Coletor de Lixo:
        - Baseado em marcar e varrer.
        - Executado automaticamente pelo runtime, mas pode ser acionado manualmente: GC.gc()
        Geracional: 
            - Coletores parciais s√£o mais r√°pidos pois percorrem vari√°veis mais recentes, ent√£o rodam mais frequentemente.
            - Coletores completos s√£o mais lentos e percorrem todas as vari√°veis menos frequentemente.
        - O coletor √© lento, mas o programa prioriza evitar necessitar dele.
            ex: ao definir que structs s√£o imut√°veis por padr√£o, encoraja o uso de structs imut√°veis, que gastam menos mem√≥ria.
            
    Tratamento de exce√ß√£o: 
        - Blocos try, catch, e finally 
            * M√≥dulos MenuProduto.jl e MenuVenda.jl *
        
    Sobrecarga:
        - Atrav√©s de M√∫ltiplo despacho. 
        - Ao contr√°rio da sobrecarga, onde o programa decide qual fun√ß√£o utilizar em tempo de compila√ß√£o,
        o m√∫ltiplo despacho ocorre em tempo de execu√ß√£o.

    Sobrescrita:
        - Como n√£o h√° heran√ßa, n√£o h√° sobrescrita tradicional.

    Cabe√ßalho, Corpo e Assinatura de Fun√ß√µes:
        Estrutura b√°sica de uma fun√ß√£o:
            * Package data *
       
    Coer√ß√£o e Cast:
        - Coer√ß√£o de Tipos expl√≠cito (convert())

            x = convert(Float64, 10)  # 10.0

        - Cast Impl√≠cito (Promo√ß√£o de Tipos)

            x = 3 + 4.5  # Resultado √© Float64 (3 promovido para 3.0)

    Subprogramas de Primeira Classe e Alta Ordem:
        - Fun√ß√µes podem ser passadas como argumentos e retornadas como valores.
            * M√≥dulo DAO.jl * 

    Avalia√ß√£o Curto Circuito:
        - Operadores l√≥gicos & e |, a express√£o √© avaliada toda.
        - Operadores l√≥gicos && e ||, segundo operando s√≥ √© avaliado se necess√°rio.
            * M√≥dulos MenuProduto e MenuVenda *
    
    Efeito colateral:
        - O ! no nome da fun√ß√£o √© uma conven√ß√£o em Julia para indicar que a fun√ß√£o modifica seus argumentos.
        - Fun√ß√µes sem o ! s√£o chamadas fun√ß√µes puras e n√£o alteram nada fora de seu escopo e sempre retorna o 
        mesmo resultado para os mesmos argumentos.
            * Package data *

    Sobrecarga de Operadores:
        - Julia permite redefinir operadores para novos tipos de dados.
            * M√≥dulo Produto.jl *

    Tipagem:
        - Tipagem Din√¢mica (Inferida), Expl√≠cita e param√©trica (tipos gen√©ricos).
            * M√≥dulo Produto.jl, DAO.jl, MenuProduto.jl e MenuVenda.jl *

    Tuplas:
        - Imut√°veis e armazenam valores heterog√™neos.
        tupla = (1, "Julia", 3.14)
            println(tupla[2])  # "Julia"
        - Tamb√©m podem ter tipos expl√≠citos:
        tupla::Tuple{Int, String, Float64} = (1, "Texto", 2.5)

    Uni√µes:
        - Permite definir vari√°veis que aceitam m√∫ltiplos tipos.
        struct Numero
            valor::Union{Int, Float64}
        end
        x::Union{Int, Float64} = 10

    Dicion√°rios:
        - Permite criar uma tabela hash com chaves
        Dict([("A", 1), ("B", 2)]) ou Dict("A"=>1, "B"=>2):
        Dict{String, Int64} with 2 entries:
            "B" => 2
            "A" => 1


Cap√≠tulo 4: ‚≠ê Curiosidades

    Interoperabilidade - chamar bibliotecas de outras linguagens, como C, python, rust, fortran
        ex: biblioteca PyCall permite usar c√≥digos em Python:
            using PyCall
            py"""
            def print_one_number(my_number):  
                print(my_number)   
                return my_number
            """
            my_number = 10
            py"print_one_number"(my_number)
    Bibliotecas de Julia tamb√©m podem ser utilizadas por outras linguagens como Python e R.
    
    Paralelismo + Falta de Global Interpreter Lock - paraleliza√ß√£o de tarefas e  execu√ß√µes multithreaded

    Suporta Unicode como entrada e como parte do c√≥digo, incluindo emojis.

    Uso cient√≠fico - diversas bibliotecas e pacotes voltados para a √°lgebra linear, visualiza√ß√£o de dados, aprendizado de m√°quina
        ex: biblioteca UnicodePlots permite a visualiza√ß√£o de dados por meio de plots desenhados em ascii, que podem ser at√© mesmo de figuras tridimensionais.
    
    

Divis√£o da Apresenta√ß√£o

    Pessoa 1 - Introdu√ß√£o e Hist√≥ria da Julia
        Cap√≠tulo 1: Julia
            O que √© Julia
            Hist√≥ria e origem
            Licen√ßa
            Caracter√≠sticas principais
            Implementa√ß√£o (Compila√ß√£o JIT)
            Aplica√ß√µes

    Pessoa 2 - Paradigmas e Orienta√ß√£o a Objetos
        Cap√≠tulo 2: Paradigmas e suas limita√ß√µes
            Multiparadigma
            M√∫ltiplo despacho
            Limita√ß√µes da orienta√ß√£o a objetos
            Structs e Mutable Structs
            Construtores
            Destrutores

    Pessoa 3 - Recursos Avan√ßados da Linguagem
        Cap√≠tulo 3: Adicionais (Parte 1)
            Vincula√ß√£o din√¢mica e m√∫ltiplo despacho
            Aloca√ß√£o e desaloca√ß√£o
            Coletor de lixo (funcionamento e otimiza√ß√£o)
            Tratamento de exce√ß√£o
            Sobrecarga e sobrescrita
            Estrutura das fun√ß√µes

    Pessoa 4 - Recursos Avan√ßados e Tipagem
        Cap√≠tulo 3: Adicionais (Parte 2)
            Coer√ß√£o e cast
            Fun√ß√µes de alta ordem
            Avalia√ß√£o curto-circuito
            Efeito colateral (! em fun√ß√µes)
            Sobrecarga de operadores
            Tipagem
            Tuplas
            Uni√µes
            Dicion√°rios

    Pessoa 5 - Curiosidades e Interoperabilidade
        Cap√≠tulo 4: ‚≠ê Curiosidades
            Interoperabilidade com outras linguagens
            Paralelismo e Global Interpreter Lock
            Unicode e emojis
            Uso cient√≠fico
    